----- Ideas for development -----

1. LCVARclust
KEY THINGS
- Anja: Implement additional Information Criteria (e.g., standard AIC, BIC) in LCVARclust function which might work well for K-selection
- Jonas: Think about S3 methods to present this nicer; look into how other packages (e.g., mclust) did this

POLISHING
- Structure the output object more intuitively
    - On the top level there should be
      - Call
        - Copy *full* function call
      - Model selection / ICs for all fitted models
      - Then object with selected model
      - And nested object with all fitted models
    - avoid [[1]] in LCVAR_out$BestSolutionsPerCluster
    - Make the output vectors "$LogLikelihood" and "EMiterationReset" only as long as many iterations were actually run
- Consider parallelize (e.g., across EM-restarts)
- Consider a simpler progress bar
    - maybe across random restarts
- Complete manual
    - some explanations missing, e.g. what Rational starts are
    - Description of output missing

2. S3 Methods
- print for LCVARclust incl model selection
- summary for LCVARclust incl model selection function
- plot for new model selection function

3. Add a Vignette
- Fit cluster=2 model
- Visualize different parameters (with native and other functions, e.g. qgraph)
- Do model selection across Ncluster sequence

4. Add unit tests

5. Things parked for (much) later
- Potentially get Standard errors for parameters, to be able to test differences in specific parameters across specific groups [After last meeting: still has to be figured out]


----- Questions -----

1. How does the data handle missing data / unequal time steps? I think there is no input arguments for things like "days" and "measurement occasion per day"? Are those two things together coded in the argument "Time"?
2. Why use "invisible()" instead of "return()" to return objects from functions?
3. Why is the object LCVAR_out$BestSolutionsPerCluster a list with 1 entry, if all the cluster info is in this list entry? (I guess we already notes this last time, see above); I tried to get rid of this in callEMFuncs.R, but didn't manage
4. What is the rational EM-start? Some mean-based clustering or so?




